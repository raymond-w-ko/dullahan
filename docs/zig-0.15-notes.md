# Zig 0.15 Notes

This documents Zig 0.15 changes from earlier versions (0.11/0.12/0.13).

## build.zig.zon

### Package name is an enum literal, not a string

```zig
// ❌ Old (0.11-0.13)
.name = "dullahan",

// ✅ New (0.15)
.name = .dullahan,
```

### Required `fingerprint` field

New packages must include a fingerprint for identity tracking:

```zig
.{
    .name = .dullahan,
    .version = "0.0.1",
    .fingerprint = 0xbf95c78e9ce4f53f,  // Generated by zig
    .minimum_zig_version = "0.15.2",
    // ...
}
```

If you provide an invalid fingerprint, zig will tell you the correct value:
```
error: invalid fingerprint: 0x...; if this is a new or forked package, use this value: 0x...
```

---

## build.zig

### Executable creation uses `root_module` instead of `root_source_file`

```zig
// ❌ Old (0.11-0.13)
const exe = b.addExecutable(.{
    .name = "dullahan",
    .root_source_file = b.path("src/main.zig"),
    .target = target,
    .optimize = optimize,
});

// ✅ New (0.15)
const exe = b.addExecutable(.{
    .name = "dullahan",
    .root_module = b.createModule(.{
        .root_source_file = b.path("src/main.zig"),
        .target = target,
        .optimize = optimize,
    }),
});
```

### Module imports are explicit

To import one module from another:

```zig
const lib_mod = b.addModule("mylib", .{
    .root_source_file = b.path("src/root.zig"),
    .target = target,
});

const exe = b.addExecutable(.{
    .name = "myapp",
    .root_module = b.createModule(.{
        .root_source_file = b.path("src/main.zig"),
        .target = target,
        .optimize = optimize,
        .imports = &.{
            .{ .name = "mylib", .module = lib_mod },
        },
    }),
});
```

Then in `main.zig`:
```zig
const mylib = @import("mylib");  // Works because of .imports
```

### Test creation uses `root_module`

```zig
// ❌ Old
const tests = b.addTest(.{
    .root_source_file = b.path("src/main.zig"),
    .target = target,
    .optimize = optimize,
});

// ✅ New
const tests = b.addTest(.{
    .root_module = some_module,  // Pass the module directly
});

// Or for exe's module:
const exe_tests = b.addTest(.{
    .root_module = exe.root_module,
});
```

---

## Project Structure (Recommended for 0.15)

The idiomatic structure separates library code from the executable:

```
src/
├── main.zig     # Executable entry point, imports "mylib"
├── root.zig     # Library root, re-exports submodules
└── *.zig        # Library submodules
```

`build.zig` creates two modules:
1. **Library module** (`b.addModule`) — exposed to consumers, testable
2. **Executable module** (`b.createModule`) — imports the library, has `main()`

This allows:
- Library tests run independently
- Executable tests can also run
- External packages can import just the library

---

## Summary of Breaking Changes

| Feature | Old | New (0.15) |
|---------|-----|------------|
| Package name | `"string"` | `.enum_literal` |
| Fingerprint | Not required | Required |
| Executable | `.root_source_file` | `.root_module` |
| Module imports | Implicit via `@import` path | Explicit `.imports` list |
| Test creation | `.root_source_file` | `.root_module` |
