# Zig 0.15 Notes

This documents Zig 0.15 breaking changes from earlier versions (0.11/0.12/0.13/0.14).

> **Source**: [Zig 0.15.1 Release Notes](https://ziglang.org/download/0.15.1/release-notes.html)

---

## build.zig.zon

### Package name is an enum literal, not a string

```zig
// ❌ Old (0.11-0.14)
.name = "dullahan",

// ✅ New (0.15)
.name = .dullahan,
```

### Required `fingerprint` field

New packages must include a fingerprint for identity tracking:

```zig
.{
    .name = .dullahan,
    .version = "0.0.1",
    .fingerprint = 0xbf95c78e9ce4f53f,  // Generated by zig
    .minimum_zig_version = "0.15.2",
    // ...
}
```

If you provide an invalid fingerprint, zig will tell you the correct value:
```
error: invalid fingerprint: 0x...; if this is a new or forked package, use this value: 0x...
```

---

## build.zig

### Executable creation uses `root_module` instead of `root_source_file`

```zig
// ❌ Old (0.11-0.14)
const exe = b.addExecutable(.{
    .name = "dullahan",
    .root_source_file = b.path("src/main.zig"),
    .target = target,
    .optimize = optimize,
});

// ✅ New (0.15)
const exe = b.addExecutable(.{
    .name = "dullahan",
    .root_module = b.createModule(.{
        .root_source_file = b.path("src/main.zig"),
        .target = target,
        .optimize = optimize,
    }),
});
```

### Module imports are explicit

To import one module from another:

```zig
const lib_mod = b.addModule("mylib", .{
    .root_source_file = b.path("src/root.zig"),
    .target = target,
});

const exe = b.addExecutable(.{
    .name = "myapp",
    .root_module = b.createModule(.{
        .root_source_file = b.path("src/main.zig"),
        .target = target,
        .optimize = optimize,
        .imports = &.{
            .{ .name = "mylib", .module = lib_mod },
        },
    }),
});
```

Then in `main.zig`:
```zig
const mylib = @import("mylib");  // Works because of .imports
```

### Test creation uses `root_module`

```zig
// ❌ Old
const tests = b.addTest(.{
    .root_source_file = b.path("src/main.zig"),
    .target = target,
    .optimize = optimize,
});

// ✅ New
const tests = b.addTest(.{
    .root_module = some_module,  // Pass the module directly
});

// Or for exe's module:
const exe_tests = b.addTest(.{
    .root_module = exe.root_module,
});
```

---

## Language Changes

### `usingnamespace` Removed

The `usingnamespace` keyword has been completely removed. Migration strategies:

**Conditional inclusion** — just include unconditionally (lazy compilation handles it):
```zig
// ❌ Old
pub usingnamespace if (have_foo) struct {
    pub const foo = 123;
} else struct {};

// ✅ New — just include it, or use compile error
pub const foo = if (have_foo) 123 else @compileError("foo not supported");
```

**Mixins** — use zero-bit fields with `@fieldParentPtr`:
```zig
// ❌ Old
pub const Foo = struct {
    count: u32 = 0,
    pub usingnamespace CounterMixin(Foo);
};
// Usage: foo.incrementCounter()

// ✅ New — zero-bit field namespace
pub const Foo = struct {
    count: u32 = 0,
    counter: CounterMixin(Foo) = .{},
};
// Usage: foo.counter.increment()
```

### `async` and `await` Keywords Removed

These keywords are gone from the language. They will return as standard library functions
as part of the new I/O interface. Also removed: `@frameSize`.

### Switch on Non-Exhaustive Enums

Now allows mixing explicit tags with `_` prong, and both `else` and `_`:

```zig
switch (enum_val) {
    .special_case_1 => foo(),
    .special_case_2 => bar(),
    _ => baz(),              // unnamed values
    else => default(),       // other named tags
}
```

---

## Standard Library Changes

### ArrayList: Unmanaged is Now Default ("Writergate")

**The big one.** `std.ArrayList` now requires passing the allocator to every method call.

```zig
// ❌ Old (0.14)
var list = std.ArrayList(u8).init(allocator);
try list.append(42);
list.deinit();

// ✅ New (0.15) — pass allocator to methods
var list = std.ArrayList(u8).init(allocator);
try list.append(allocator, 42);  // allocator required!
list.deinit(allocator);          // here too!
```

**Option 1**: Store allocator in your struct and pass it everywhere:
```zig
const MyStruct = struct {
    items: std.ArrayList(Item),
    allocator: std.mem.Allocator,

    fn addItem(self: *MyStruct, item: Item) !void {
        try self.items.append(self.allocator, item);
    }
};
```

**Option 2**: Use `ArrayListUnmanaged` (now the "base" implementation):
```zig
const MyStruct = struct {
    items: std.ArrayListUnmanaged(Item) = .{},

    fn addItem(self: *MyStruct, allocator: std.mem.Allocator, item: Item) !void {
        try self.items.append(allocator, item);
    }
};
```

### HashMap: Same Pattern Applies

`std.HashMap`, `std.StringHashMap`, and `std.AutoHashMap` follow the same pattern:

```zig
// ❌ Old (0.14)
var map = std.StringHashMap(Value).init(allocator);
try map.put("key", value);
map.deinit();

// ✅ New (0.15) — use Unmanaged variants
var map: std.StringHashMapUnmanaged(Value) = .{};
defer map.deinit(allocator);
try map.put(allocator, "key", value);

// Also for AutoHashMap
var auto_map: std.AutoHashMapUnmanaged(u32, Value) = .{};
defer auto_map.deinit(allocator);
try auto_map.put(allocator, 123, value);
```

Key differences:
- Initialize with `.{}` (empty struct literal) not `.init(allocator)`
- Pass `allocator` to `put()`, `get()` (if needed), `deinit()`
- `get()` doesn't need allocator, but `put()`, `remove()`, `deinit()` do

### Writer/Reader API Rewrite

Major changes to I/O types to reduce generic code bloat:

- `std.io.Writer` → `std.Io.Writer`
- `std.io.Reader` → `std.Io.Reader`
- `CountingWriter` — deleted
- `BufferedWriter` — deleted

```zig
// ❌ Old
const stdout = std.io.getStdOut().writer();
try stdout.print("hello\n", .{});

// ✅ New
const stdout = std.io.getStdOut();
try stdout.writeAll("hello\n");
// Or for formatted:
var buf: [256]u8 = undefined;
const msg = std.fmt.bufPrint(&buf, "value: {}\n", .{42}) catch unreachable;
try stdout.writeAll(msg);
```

### Format String Changes

- `"{f}"` now required to call custom format methods
- Format methods no longer receive format strings or options
- Formatted printing no longer handles Unicode width

### BoundedArray Removed

Use `std.ArrayListUnmanaged` with a fixed-size backing buffer, or `[N]T` directly.

### Linked Lists De-Genericified

`std.SinglyLinkedList` and `std.DoublyLinkedList` API changes.

---

## Process API Changes

`std.process.Child.run()` return type changed:

```zig
// ❌ Old
if (result.term.Exited != 0) { ... }

// ✅ New — term is a tagged union
switch (result.term) {
    .exited => |code| if (code != 0) { ... },
    .signaled => |sig| { ... },
    // etc.
}
```

---

## Project Structure (Recommended for 0.15)

The idiomatic structure separates library code from the executable:

```
src/
├── main.zig     # Executable entry point, imports "mylib"
├── root.zig     # Library root, re-exports submodules
└── *.zig        # Library submodules
```

`build.zig` creates two modules:
1. **Library module** (`b.addModule`) — exposed to consumers, testable
2. **Executable module** (`b.createModule`) — imports the library, has `main()`

This allows:
- Library tests run independently
- Executable tests can also run
- External packages can import just the library

---

## Summary of Breaking Changes

| Feature | Old | New (0.15) |
|---------|-----|------------|
| Package name | `"string"` | `.enum_literal` |
| Fingerprint | Not required | Required |
| Executable | `.root_source_file` | `.root_module` |
| Module imports | Implicit via `@import` path | Explicit `.imports` list |
| Test creation | `.root_source_file` | `.root_module` |
| `usingnamespace` | Supported | Removed |
| `async`/`await` | Keywords | Removed (coming back as stdlib) |
| ArrayList.append | `list.append(item)` | `list.append(allocator, item)` |
| HashMap.put | `map.put(k, v)` | `map.put(allocator, k, v)` |
| Writer/Reader | `std.io.Writer` | `std.Io.Writer` |
| std.io.getStdIn() | Returns File | Removed (use posix.STDIN_FILENO) |
| File.writer() | No args | Requires buffer argument |
| BoundedArray | `std.BoundedArray` | Removed |
| process.Child.term | `.Exited` field | Tagged union |

---

## Additional API Changes

### `std.time.sleep` → `std.Thread.sleep`

```zig
// ❌ Old
std.time.sleep(100 * std.time.ns_per_ms);

// ✅ New
std.Thread.sleep(100 * std.time.ns_per_ms);
```

### Error sets cannot be discarded with `_ = e`

```zig
// ❌ Old
something() catch |e| {
    _ = e;  // Error: error set is discarded
};

// ✅ New — just don't capture it
something() catch {
    // handle error without capturing
};
```

### `std.c.getpid()` instead of `std.os.linux.getpid()`

For cross-platform PID access:
```zig
const pid = std.c.getpid();
```

---

## Format String Pitfalls

### Ambiguous Format Specifiers

In 0.15, `{}` is ambiguous for types that have custom format methods. You'll get:
```
error: ambiguous format string; specify {f} to call format method, or {any} to skip it
```

**Common types that need explicit specifiers:**

```zig
// ❌ These will fail
log.err("Error: {}", .{some_error});
log.info("Address: {}", .{socket_address});
log.debug("Value: {}", .{self.running});  // bool in some contexts

// ✅ Use {any} for safety
log.err("Error: {any}", .{some_error});
log.info("Address: {any}", .{socket_address});
log.debug("Value: {any}", .{self.running});

// ✅ Or use specific formatters
log.info("Count: {d}", .{count});      // integers
log.info("Name: {s}", .{name});        // strings
log.info("Flag: {}", .{@as(u8, if (flag) 1 else 0)});  // convert bool
```

**Rule of thumb**: If you're logging an error, address, or any complex type, use `{any}`.

---

## ArrayListUnmanaged Patterns

The idiomatic pattern for building strings/buffers in 0.15:

```zig
// ✅ Correct pattern
pub fn buildString(allocator: std.mem.Allocator) ![]u8 {
    var buf: std.ArrayListUnmanaged(u8) = .{};
    errdefer buf.deinit(allocator);
    
    const writer = buf.writer(allocator);
    try writer.writeAll("Hello ");
    try writer.print("{d}", .{42});
    
    return buf.toOwnedSlice(allocator);
}

// ❌ Old pattern (won't compile)
var buf = std.ArrayList(u8).init(allocator);
const writer = buf.writer();  // writer() now needs allocator!
```

Key points:
- Initialize with `.{}` (empty struct literal)
- Pass `allocator` to `writer()`, `append()`, `deinit()`, `toOwnedSlice()`
- Use `errdefer buf.deinit(allocator)` for cleanup on error

---

## File I/O Changes

### std.io.getStdIn() / getStdOut() Removed

These convenience functions no longer exist. Use POSIX file descriptors directly:

```zig
// ❌ Old
const stdin = std.io.getStdIn();
const stdout = std.io.getStdOut().writer();
const n = try stdin.read(&buf);
try stdout.writeAll("hello\n");

// ✅ New — use posix file descriptors
const stdin_fd = std.posix.STDIN_FILENO;
const stdout_fd = std.posix.STDOUT_FILENO;
const n = try std.posix.read(stdin_fd, &buf);
_ = try std.posix.write(stdout_fd, "hello\n");
```

### File.writer() Requires Buffer

```zig
// ❌ Old
const writer = file.writer();
try writer.print("hello {}\n", .{name});

// ✅ New — use writeAll + bufPrint
var buf: [4096]u8 = undefined;
const msg = std.fmt.bufPrint(&buf, "hello {s}\n", .{name}) catch return;
file.writeAll(msg) catch return;

// ✅ Or use ArrayListUnmanaged for dynamic sizing
var out: std.ArrayListUnmanaged(u8) = .{};
defer out.deinit(allocator);
const writer = out.writer(allocator);
try writer.print("hello {s}\n", .{name});
try file.writeAll(out.items);
```

### Pattern: Building Output with fixedBufferStream

For simple programs that build output strings, use `fixedBufferStream`:

```zig
fn render(fd: std.posix.fd_t) void {
    var buf: [4096]u8 = undefined;
    var fbs = std.io.fixedBufferStream(&buf);
    const w = fbs.writer();

    // Build output using the writer
    w.writeAll("Header\n") catch {};
    std.fmt.format(w, "Value: 0x{x:0>2}\n", .{value}) catch {};
    w.writeAll("Footer\n") catch {};

    // Write all at once
    _ = std.posix.write(fd, fbs.getWritten()) catch {};
}
```

This pattern:
- Avoids multiple syscalls (single write)
- No allocator needed
- Works well for terminal output, status displays, etc.

---

## Platform-Specific Code

### @cImport with Conditionals

```zig
const builtin = @import("builtin");

const c = @cImport({
    @cInclude("sys/ioctl.h");
    if (builtin.os.tag == .macos) {
        @cInclude("util.h");      // openpty() on macOS
    } else {
        @cInclude("pty.h");       // openpty() on Linux
    }
    @cInclude("termios.h");
});
```

Common platform differences:
| Function | macOS | Linux |
|----------|-------|-------|
| `openpty()` | `<util.h>` | `<pty.h>` |
| `forkpty()` | `<util.h>` | `<pty.h>` |

---

## Compiler Improvements (Non-Breaking)

- **5x faster debug builds** with x86 backend (now default)
- **Incremental compilation** improvements
- **Threaded codegen** for faster release builds
- **LLVM 20** backend
- **Fuzzer** built-in support

---

## zig-msgpack Library

MessagePack binary serialization library for efficient data encoding. Used in dullahan for WebSocket binary messages.

**Source**: [github.com/zigcc/zig-msgpack](https://github.com/zigcc/zig-msgpack)

### Adding as Dependency

`build.zig.zon`:
```zig
.@"zig-msgpack" = .{
    .url = "git+https://github.com/zigcc/zig-msgpack#COMMIT_HASH",
    .hash = "...",  // zig build will tell you the correct hash
},
```

`build.zig`:
```zig
if (b.lazyDependency("zig-msgpack", .{})) |msgpack_dep| {
    const msgpack = msgpack_dep.module("msgpack");
    my_module.addImport("msgpack", msgpack);
}
```

### Basic Types

```zig
const msgpack = @import("msgpack");
const Payload = msgpack.Payload;

// Primitives (no allocation)
const nil_val = Payload.nilToPayload();
const bool_val = Payload.boolToPayload(true);
const int_val = Payload.intToPayload(-42);
const uint_val = Payload.uintToPayload(42);
const float_val = Payload.floatToPayload(3.14);

// Strings/Binary (allocates, must free)
const str_val = try Payload.strToPayload("hello", allocator);
defer str_val.free(allocator);

const bin_val = try Payload.binToPayload(&[_]u8{1, 2, 3}, allocator);
defer bin_val.free(allocator);

// Timestamp
const ts = Payload.timestampToPayload(1234567890, 123456789);  // secs, nanos
```

### Arrays

```zig
// Create array with fixed length
var arr = try Payload.arrPayload(3, allocator);
defer arr.free(allocator);

// Set elements by index
try arr.setArrElement(0, Payload.intToPayload(1));
try arr.setArrElement(1, Payload.intToPayload(2));
try arr.setArrElement(2, Payload.intToPayload(3));

// Read back
const len = try arr.getArrLen();
const elem = try arr.getArrElement(0);
std.debug.print("First: {d}\n", .{elem.int});
```

### Maps

```zig
// Create map
var map = Payload.mapPayload(allocator);
defer map.free(allocator);

// String keys (common case)
try map.mapPut("name", try Payload.strToPayload("Alice", allocator));
try map.mapPut("age", Payload.uintToPayload(30));

// Read back
if (try map.mapGet("name")) |name| {
    std.debug.print("Name: {s}\n", .{name.str.value()});
}

// Generic keys (any Payload type)
try map.mapPutGeneric(Payload.intToPayload(1), Payload.strToPayload("one", allocator));
```

### Encoding/Decoding with compat layer (Recommended)

The `compat` layer works across Zig 0.14, 0.15, and 0.16:

```zig
const msgpack = @import("msgpack");
const compat = msgpack.compat;

// Create buffer streams
var buffer: [4096]u8 = undefined;
var write_stream = compat.fixedBufferStream(&buffer);
var read_stream = compat.fixedBufferStream(&buffer);

// Create packer
const BufferType = compat.BufferStream;
var packer = msgpack.Pack(
    *BufferType, *BufferType,
    BufferType.WriteError, BufferType.ReadError,
    BufferType.write, BufferType.read,
).init(&write_stream, &read_stream);

// Encode
var payload = Payload.mapPayload(allocator);
defer payload.free(allocator);
try payload.mapPut("type", try Payload.strToPayload("snapshot", allocator));
try payload.mapPut("cols", Payload.uintToPayload(80));
try packer.write(payload);

// Decode
read_stream.pos = 0;  // Reset read position
const decoded = try packer.read(allocator);
defer decoded.free(allocator);

const msg_type = (try decoded.mapGet("type")).?.str.value();
const cols = (try decoded.mapGet("cols")).?.uint;
```

### Type Conversion

```zig
// Lenient (allows conversion)
const int_as_i64 = try payload.getInt();   // uint -> i64 if fits
const uint_as_u64 = try payload.getUint(); // positive int -> u64

// Strict (no conversion)
const strict_int = try payload.asInt();    // only .int type
const strict_uint = try payload.asUint();  // only .uint type
const strict_str = try payload.asStr();    // only .str type

// Type checking
if (payload.isNil()) { ... }
if (payload.isNumber()) { ... }      // int, uint, or float
if (payload.isInteger()) { ... }     // int or uint only
```

### Security Limits

For parsing untrusted data, use `PackWithLimits`:

```zig
const SafePacker = msgpack.PackWithLimits(
    *BufferType, *BufferType,
    BufferType.WriteError, BufferType.ReadError,
    BufferType.write, BufferType.read,
    .{
        .max_depth = 50,              // Max nesting
        .max_array_length = 10_000,   // Max array elements
        .max_map_size = 10_000,       // Max map pairs
        .max_string_length = 1024 * 1024,  // Max 1MB strings
    },
);
```

Possible security errors:
- `MaxDepthExceeded` — nesting too deep
- `ArrayTooLarge` — array claims too many elements
- `MapTooLarge` — map claims too many pairs
- `StringTooLong` — string data too large

### Memory Management

**Important**: Payloads that allocate memory must be freed:
- `strToPayload` — allocates string copy
- `binToPayload` — allocates binary copy
- `arrPayload` — allocates array
- `mapPayload` — allocates map
- `extToPayload` — allocates extension data

```zig
const payload = try Payload.strToPayload("hello", allocator);
defer payload.free(allocator);  // REQUIRED

// For nested structures, free only the root
var map = Payload.mapPayload(allocator);
try map.mapPut("nested", try Payload.strToPayload("value", allocator));
defer map.free(allocator);  // Frees map AND nested string
```

### Binary Data Pattern for WebSocket

Typical pattern for sending binary msgpack over WebSocket:

```zig
fn encodeSnapshot(allocator: Allocator, cols: u16, rows: u16, cells: []const u8) ![]u8 {
    var buffer: [65536]u8 = undefined;
    var write_stream = compat.fixedBufferStream(&buffer);
    var read_stream = compat.fixedBufferStream(&buffer);

    const BufferType = compat.BufferStream;
    var packer = msgpack.Pack(
        *BufferType, *BufferType,
        BufferType.WriteError, BufferType.ReadError,
        BufferType.write, BufferType.read,
    ).init(&write_stream, &read_stream);

    var payload = Payload.mapPayload(allocator);
    defer payload.free(allocator);

    try payload.mapPut("type", try Payload.strToPayload("snapshot", allocator));
    try payload.mapPut("cols", Payload.uintToPayload(cols));
    try payload.mapPut("rows", Payload.uintToPayload(rows));
    try payload.mapPut("cells", try Payload.binToPayload(cells, allocator));

    try packer.write(payload);

    // Return copy of encoded bytes
    const encoded_len = write_stream.pos;
    const result = try allocator.alloc(u8, encoded_len);
    @memcpy(result, buffer[0..encoded_len]);
    return result;
}
```
