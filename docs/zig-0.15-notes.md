# Zig 0.15 Notes

This documents Zig 0.15 breaking changes from earlier versions (0.11/0.12/0.13/0.14).

> **Source**: [Zig 0.15.1 Release Notes](https://ziglang.org/download/0.15.1/release-notes.html)

---

## build.zig.zon

### Package name is an enum literal, not a string

```zig
// ❌ Old (0.11-0.14)
.name = "dullahan",

// ✅ New (0.15)
.name = .dullahan,
```

### Required `fingerprint` field

New packages must include a fingerprint for identity tracking:

```zig
.{
    .name = .dullahan,
    .version = "0.0.1",
    .fingerprint = 0xbf95c78e9ce4f53f,  // Generated by zig
    .minimum_zig_version = "0.15.2",
    // ...
}
```

If you provide an invalid fingerprint, zig will tell you the correct value:
```
error: invalid fingerprint: 0x...; if this is a new or forked package, use this value: 0x...
```

---

## build.zig

### Executable creation uses `root_module` instead of `root_source_file`

```zig
// ❌ Old (0.11-0.14)
const exe = b.addExecutable(.{
    .name = "dullahan",
    .root_source_file = b.path("src/main.zig"),
    .target = target,
    .optimize = optimize,
});

// ✅ New (0.15)
const exe = b.addExecutable(.{
    .name = "dullahan",
    .root_module = b.createModule(.{
        .root_source_file = b.path("src/main.zig"),
        .target = target,
        .optimize = optimize,
    }),
});
```

### Module imports are explicit

To import one module from another:

```zig
const lib_mod = b.addModule("mylib", .{
    .root_source_file = b.path("src/root.zig"),
    .target = target,
});

const exe = b.addExecutable(.{
    .name = "myapp",
    .root_module = b.createModule(.{
        .root_source_file = b.path("src/main.zig"),
        .target = target,
        .optimize = optimize,
        .imports = &.{
            .{ .name = "mylib", .module = lib_mod },
        },
    }),
});
```

Then in `main.zig`:
```zig
const mylib = @import("mylib");  // Works because of .imports
```

### Test creation uses `root_module`

```zig
// ❌ Old
const tests = b.addTest(.{
    .root_source_file = b.path("src/main.zig"),
    .target = target,
    .optimize = optimize,
});

// ✅ New
const tests = b.addTest(.{
    .root_module = some_module,  // Pass the module directly
});

// Or for exe's module:
const exe_tests = b.addTest(.{
    .root_module = exe.root_module,
});
```

---

## Language Changes

### `usingnamespace` Removed

The `usingnamespace` keyword has been completely removed. Migration strategies:

**Conditional inclusion** — just include unconditionally (lazy compilation handles it):
```zig
// ❌ Old
pub usingnamespace if (have_foo) struct {
    pub const foo = 123;
} else struct {};

// ✅ New — just include it, or use compile error
pub const foo = if (have_foo) 123 else @compileError("foo not supported");
```

**Mixins** — use zero-bit fields with `@fieldParentPtr`:
```zig
// ❌ Old
pub const Foo = struct {
    count: u32 = 0,
    pub usingnamespace CounterMixin(Foo);
};
// Usage: foo.incrementCounter()

// ✅ New — zero-bit field namespace
pub const Foo = struct {
    count: u32 = 0,
    counter: CounterMixin(Foo) = .{},
};
// Usage: foo.counter.increment()
```

### `async` and `await` Keywords Removed

These keywords are gone from the language. They will return as standard library functions
as part of the new I/O interface. Also removed: `@frameSize`.

### Switch on Non-Exhaustive Enums

Now allows mixing explicit tags with `_` prong, and both `else` and `_`:

```zig
switch (enum_val) {
    .special_case_1 => foo(),
    .special_case_2 => bar(),
    _ => baz(),              // unnamed values
    else => default(),       // other named tags
}
```

---

## Standard Library Changes

### ArrayList: Unmanaged is Now Default ("Writergate")

**The big one.** `std.ArrayList` now requires passing the allocator to every method call.

```zig
// ❌ Old (0.14)
var list = std.ArrayList(u8).init(allocator);
try list.append(42);
list.deinit();

// ✅ New (0.15) — pass allocator to methods
var list = std.ArrayList(u8).init(allocator);
try list.append(allocator, 42);  // allocator required!
list.deinit(allocator);          // here too!
```

**Option 1**: Store allocator in your struct and pass it everywhere:
```zig
const MyStruct = struct {
    items: std.ArrayList(Item),
    allocator: std.mem.Allocator,

    fn addItem(self: *MyStruct, item: Item) !void {
        try self.items.append(self.allocator, item);
    }
};
```

**Option 2**: Use `ArrayListUnmanaged` (now the "base" implementation):
```zig
const MyStruct = struct {
    items: std.ArrayListUnmanaged(Item) = .{},

    fn addItem(self: *MyStruct, allocator: std.mem.Allocator, item: Item) !void {
        try self.items.append(allocator, item);
    }
};
```

### Writer/Reader API Rewrite

Major changes to I/O types to reduce generic code bloat:

- `std.io.Writer` → `std.Io.Writer`
- `std.io.Reader` → `std.Io.Reader`
- `CountingWriter` — deleted
- `BufferedWriter` — deleted

```zig
// ❌ Old
const stdout = std.io.getStdOut().writer();
try stdout.print("hello\n", .{});

// ✅ New
const stdout = std.io.getStdOut();
try stdout.writeAll("hello\n");
// Or for formatted:
var buf: [256]u8 = undefined;
const msg = std.fmt.bufPrint(&buf, "value: {}\n", .{42}) catch unreachable;
try stdout.writeAll(msg);
```

### Format String Changes

- `"{f}"` now required to call custom format methods
- Format methods no longer receive format strings or options
- Formatted printing no longer handles Unicode width

### BoundedArray Removed

Use `std.ArrayListUnmanaged` with a fixed-size backing buffer, or `[N]T` directly.

### Linked Lists De-Genericified

`std.SinglyLinkedList` and `std.DoublyLinkedList` API changes.

---

## Process API Changes

`std.process.Child.run()` return type changed:

```zig
// ❌ Old
if (result.term.Exited != 0) { ... }

// ✅ New — term is a tagged union
switch (result.term) {
    .exited => |code| if (code != 0) { ... },
    .signaled => |sig| { ... },
    // etc.
}
```

---

## Project Structure (Recommended for 0.15)

The idiomatic structure separates library code from the executable:

```
src/
├── main.zig     # Executable entry point, imports "mylib"
├── root.zig     # Library root, re-exports submodules
└── *.zig        # Library submodules
```

`build.zig` creates two modules:
1. **Library module** (`b.addModule`) — exposed to consumers, testable
2. **Executable module** (`b.createModule`) — imports the library, has `main()`

This allows:
- Library tests run independently
- Executable tests can also run
- External packages can import just the library

---

## Summary of Breaking Changes

| Feature | Old | New (0.15) |
|---------|-----|------------|
| Package name | `"string"` | `.enum_literal` |
| Fingerprint | Not required | Required |
| Executable | `.root_source_file` | `.root_module` |
| Module imports | Implicit via `@import` path | Explicit `.imports` list |
| Test creation | `.root_source_file` | `.root_module` |
| `usingnamespace` | Supported | Removed |
| `async`/`await` | Keywords | Removed (coming back as stdlib) |
| ArrayList.append | `list.append(item)` | `list.append(allocator, item)` |
| Writer/Reader | `std.io.Writer` | `std.Io.Writer` |
| BoundedArray | `std.BoundedArray` | Removed |
| process.Child.term | `.Exited` field | Tagged union |

---

## Additional API Changes

### `std.time.sleep` → `std.Thread.sleep`

```zig
// ❌ Old
std.time.sleep(100 * std.time.ns_per_ms);

// ✅ New
std.Thread.sleep(100 * std.time.ns_per_ms);
```

### Error sets cannot be discarded with `_ = e`

```zig
// ❌ Old
something() catch |e| {
    _ = e;  // Error: error set is discarded
};

// ✅ New — just don't capture it
something() catch {
    // handle error without capturing
};
```

### `std.c.getpid()` instead of `std.os.linux.getpid()`

For cross-platform PID access:
```zig
const pid = std.c.getpid();
```

---

## Format String Pitfalls

### Ambiguous Format Specifiers

In 0.15, `{}` is ambiguous for types that have custom format methods. You'll get:
```
error: ambiguous format string; specify {f} to call format method, or {any} to skip it
```

**Common types that need explicit specifiers:**

```zig
// ❌ These will fail
log.err("Error: {}", .{some_error});
log.info("Address: {}", .{socket_address});
log.debug("Value: {}", .{self.running});  // bool in some contexts

// ✅ Use {any} for safety
log.err("Error: {any}", .{some_error});
log.info("Address: {any}", .{socket_address});
log.debug("Value: {any}", .{self.running});

// ✅ Or use specific formatters
log.info("Count: {d}", .{count});      // integers
log.info("Name: {s}", .{name});        // strings
log.info("Flag: {}", .{@as(u8, if (flag) 1 else 0)});  // convert bool
```

**Rule of thumb**: If you're logging an error, address, or any complex type, use `{any}`.

---

## ArrayListUnmanaged Patterns

The idiomatic pattern for building strings/buffers in 0.15:

```zig
// ✅ Correct pattern
pub fn buildString(allocator: std.mem.Allocator) ![]u8 {
    var buf: std.ArrayListUnmanaged(u8) = .{};
    errdefer buf.deinit(allocator);
    
    const writer = buf.writer(allocator);
    try writer.writeAll("Hello ");
    try writer.print("{d}", .{42});
    
    return buf.toOwnedSlice(allocator);
}

// ❌ Old pattern (won't compile)
var buf = std.ArrayList(u8).init(allocator);
const writer = buf.writer();  // writer() now needs allocator!
```

Key points:
- Initialize with `.{}` (empty struct literal)
- Pass `allocator` to `writer()`, `append()`, `deinit()`, `toOwnedSlice()`
- Use `errdefer buf.deinit(allocator)` for cleanup on error

---

## File I/O Changes

### File.writer() Requires Buffer

```zig
// ❌ Old
const writer = file.writer();
try writer.print("hello {}\n", .{name});

// ✅ New — use writeAll + bufPrint
var buf: [4096]u8 = undefined;
const msg = std.fmt.bufPrint(&buf, "hello {s}\n", .{name}) catch return;
file.writeAll(msg) catch return;

// ✅ Or use ArrayListUnmanaged for dynamic sizing
var out: std.ArrayListUnmanaged(u8) = .{};
defer out.deinit(allocator);
const writer = out.writer(allocator);
try writer.print("hello {s}\n", .{name});
try file.writeAll(out.items);
```

---

## Platform-Specific Code

### @cImport with Conditionals

```zig
const builtin = @import("builtin");

const c = @cImport({
    @cInclude("sys/ioctl.h");
    if (builtin.os.tag == .macos) {
        @cInclude("util.h");      // openpty() on macOS
    } else {
        @cInclude("pty.h");       // openpty() on Linux
    }
    @cInclude("termios.h");
});
```

Common platform differences:
| Function | macOS | Linux |
|----------|-------|-------|
| `openpty()` | `<util.h>` | `<pty.h>` |
| `forkpty()` | `<util.h>` | `<pty.h>` |

---

## Compiler Improvements (Non-Breaking)

- **5x faster debug builds** with x86 backend (now default)
- **Incremental compilation** improvements
- **Threaded codegen** for faster release builds
- **LLVM 20** backend
- **Fuzzer** built-in support
