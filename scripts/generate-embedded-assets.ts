#!/usr/bin/env bun
/**
 * Generate embedded_assets.zig with @embedFile for all client files.
 * Used for single-binary distribution builds.
 * 
 * Copies assets into server/assets/ (inside Zig package path) then
 * generates embedded_assets.zig pointing to them.
 */

import { writeFileSync, existsSync, mkdirSync, copyFileSync, readFileSync } from "fs";

const ASSETS_DIR = "server/src/assets";
const OUTPUT_FILE = "server/src/embedded_assets.zig";

interface Asset {
  urlPath: string;     // URL path (e.g., "/index.html")
  embedPath: string;   // Path for @embedFile (relative to server/src/)
  mimeType: string;
}

function getMimeType(filename: string): string {
  const ext = filename.split(".").pop()?.toLowerCase();
  switch (ext) {
    case "html": return "text/html";
    case "css": return "text/css";
    case "js": return "application/javascript";
    case "json": return "application/json";
    case "png": return "image/png";
    case "jpg":
    case "jpeg": return "image/jpeg";
    case "svg": return "image/svg+xml";
    case "ico": return "image/x-icon";
    case "woff": return "font/woff";
    case "woff2": return "font/woff2";
    case "map": return "application/json";
    default: return "application/octet-stream";
  }
}

function ensureDir(dir: string): void {
  if (!existsSync(dir)) {
    mkdirSync(dir, { recursive: true });
  }
}

function copyAsset(src: string, dest: string): boolean {
  if (!existsSync(src)) {
    console.warn(`  Warning: ${src} not found, skipping`);
    return false;
  }
  copyFileSync(src, dest);
  return true;
}

function prepareAssets(): Asset[] {
  const assets: Asset[] = [];
  
  ensureDir(ASSETS_DIR);
  
  // Generate production index.html
  const indexHtml = `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="icon" type="image/png" href="/favicon.png">
  <link rel="stylesheet" href="/palette.css">
  <link rel="stylesheet" href="/dullahan.css">
  <link rel="stylesheet" href="/themes.css">
  <title>Dullahan</title>
</head>
<body>
  <div id="app"></div>
  <script type="module" src="/main.js"></script>
</body>
</html>`;
  writeFileSync(`${ASSETS_DIR}/index.html`, indexHtml);
  assets.push({ urlPath: "/", embedPath: "assets/index.html", mimeType: "text/html" });
  assets.push({ urlPath: "/index.html", embedPath: "assets/index.html", mimeType: "text/html" });
  
  // CSS files
  for (const css of ["palette.css", "dullahan.css", "themes.css"]) {
    if (copyAsset(`client/src/${css}`, `${ASSETS_DIR}/${css}`)) {
      assets.push({ urlPath: `/${css}`, embedPath: `assets/${css}`, mimeType: "text/css" });
    }
  }
  
  // JS bundle
  if (copyAsset("client/dist/main.js", `${ASSETS_DIR}/main.js`)) {
    assets.push({ urlPath: "/main.js", embedPath: "assets/main.js", mimeType: "application/javascript" });
  }
  
  // Favicon
  if (copyAsset("client/favicon.png", `${ASSETS_DIR}/favicon.png`)) {
    assets.push({ urlPath: "/favicon.png", embedPath: "assets/favicon.png", mimeType: "image/png" });
  }
  
  return assets;
}

function generateZigFile(assets: Asset[]): void {
  const lines: string[] = [
    "//! Embedded client assets for single-binary distribution.",
    "//! Auto-generated by scripts/generate-embedded-assets.ts",
    "//! DO NOT EDIT MANUALLY",
    "",
    "const std = @import(\"std\");",
    "",
    "pub const Asset = struct {",
    "    content: []const u8,",
    "    mime_type: []const u8,",
    "};",
    "",
    "/// Embedded asset data",
    "const assets = struct {",
  ];

  // Generate const declarations for each unique file
  const seen = new Set<string>();
  let fileIndex = 0;
  const fileMap = new Map<string, number>();
  
  for (const asset of assets) {
    if (!seen.has(asset.embedPath)) {
      seen.add(asset.embedPath);
      fileMap.set(asset.embedPath, fileIndex);
      lines.push(`    const file_${fileIndex} = @embedFile("${asset.embedPath}");`);
      fileIndex++;
    }
  }

  lines.push("};");
  lines.push("");

  // Generate the lookup table
  lines.push("/// Map of URL paths to embedded assets");
  lines.push("pub const embedded_files = std.StaticStringMap(Asset).initComptime(.{");

  for (const asset of assets) {
    const idx = fileMap.get(asset.embedPath);
    lines.push(`    .{ "${asset.urlPath}", Asset{ .content = assets.file_${idx}, .mime_type = "${asset.mimeType}" } },`);
  }

  lines.push("});");
  lines.push("");

  // Generate helper function
  lines.push("/// Get an embedded asset by path, returns null if not found");
  lines.push("pub fn get(path: []const u8) ?Asset {");
  lines.push("    return embedded_files.get(path);");
  lines.push("}");
  lines.push("");
  
  // Add hasEmbeddedAssets for runtime check
  lines.push("/// Check if we have embedded assets");
  lines.push("pub fn hasEmbeddedAssets() bool {");
  lines.push("    return embedded_files.count() > 0;");
  lines.push("}");
  lines.push("");

  writeFileSync(OUTPUT_FILE, lines.join("\n"));
  console.log(`Generated ${OUTPUT_FILE} with ${assets.length} URL mappings (${fileMap.size} unique files)`);
}

// Main
console.log("Preparing embedded assets...");
console.log(`Copying to ${ASSETS_DIR}/`);

const assets = prepareAssets();
generateZigFile(assets);

console.log("\nAssets to embed:");
for (const asset of assets) {
  console.log(`  ${asset.urlPath} -> ${asset.embedPath}`);
}
