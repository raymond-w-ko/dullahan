/**
 * Delta sync correctness tests
 *
 * These tests verify that applying a delta to snapshot A produces
 * the same result as snapshot B.
 *
 * Test fixtures are generated by the Zig `delta-test-gen` tool.
 * Run: cd server && zig build gen-delta-test
 */

import { describe, expect, test, beforeAll } from "bun:test";
import { readdir, readFile } from "fs/promises";
import { join } from "path";
import { decode } from "@msgpack/msgpack";
import SnappyJS from "snappyjs";
import type { Cell, CellContent, WideValue } from "./cell";
import { ContentTag, Wide } from "./cell";
import type { Style, StyleTable, Color, UnderlineValue } from "./style";
import { ColorTag, Underline } from "./style";
import type { BinarySnapshot, BinaryDelta } from "../../client/src/terminal/connection";

interface DecodedSnapshot {
  gen: number;
  cols: number;
  rows: number;
  cursor: {
    x: number;
    y: number;
    visible: boolean;
    style: string;
  };
  altScreen: boolean;
  cells: Cell[];
  styles: StyleTable;
  rowIds: bigint[];
}

interface TestMeta {
  name: string;
  cols: number;
  rows: number;
  gen_a: number;
  gen_b: number;
}

// ============================================================================
// Decoding functions (same as connection.ts but standalone)
// ============================================================================

function decompressMessage(data: Uint8Array): unknown {
  const isCompressed = data[0] === 1;
  const payload = data.slice(1);
  const decompressed = isCompressed ? SnappyJS.uncompress(payload) : payload;
  return decode(decompressed);
}

function decodeCellsFromBytes(data: Uint8Array): Cell[] {
  const cellSize = 8;
  const count = Math.floor(data.length / cellSize);
  const cells: Cell[] = [];

  for (let i = 0; i < count; i++) {
    const offset = i * cellSize;

    const lo =
      (data[offset] ?? 0) |
      ((data[offset + 1] ?? 0) << 8) |
      ((data[offset + 2] ?? 0) << 16) |
      ((data[offset + 3] ?? 0) << 24);
    const hi =
      (data[offset + 4] ?? 0) |
      ((data[offset + 5] ?? 0) << 8) |
      ((data[offset + 6] ?? 0) << 16) |
      ((data[offset + 7] ?? 0) << 24);

    const contentTag = (lo & 0x3) as 0 | 1 | 2 | 3;
    const contentBits = (lo >>> 2) & 0xffffff;
    const styleIdLo = (lo >>> 26) & 0x3f;
    const styleIdHi = hi & 0x3ff;
    const styleId = styleIdLo | (styleIdHi << 6);
    const wide = ((hi >>> 10) & 0x3) as WideValue;
    const isProtected = ((hi >>> 12) & 0x1) === 1;
    const isHyperlink = ((hi >>> 13) & 0x1) === 1;

    let content: CellContent;
    switch (contentTag) {
      case ContentTag.CODEPOINT:
        content = { tag: ContentTag.CODEPOINT, codepoint: contentBits & 0x1fffff };
        break;
      case ContentTag.CODEPOINT_GRAPHEME:
        content = { tag: ContentTag.CODEPOINT_GRAPHEME, codepoint: contentBits & 0x1fffff };
        break;
      case ContentTag.BG_COLOR_PALETTE:
        content = { tag: ContentTag.BG_COLOR_PALETTE, palette: contentBits & 0xff };
        break;
      case ContentTag.BG_COLOR_RGB:
        content = {
          tag: ContentTag.BG_COLOR_RGB,
          rgb: {
            r: contentBits & 0xff,
            g: (contentBits >>> 8) & 0xff,
            b: (contentBits >>> 16) & 0xff,
          },
        };
        break;
    }

    cells.push({
      content,
      styleId,
      wide,
      protected: isProtected,
      hyperlink: isHyperlink,
    });
  }

  return cells;
}

function decodeColor(data: Uint8Array, offset: number): Color {
  const tag = data[offset] ?? 0;
  switch (tag) {
    case ColorTag.NONE:
      return { tag: ColorTag.NONE };
    case ColorTag.PALETTE:
      return { tag: ColorTag.PALETTE, index: data[offset + 1] ?? 0 };
    case ColorTag.RGB:
      return {
        tag: ColorTag.RGB,
        r: data[offset + 1] ?? 0,
        g: data[offset + 2] ?? 0,
        b: data[offset + 3] ?? 0,
      };
    default:
      return { tag: ColorTag.NONE };
  }
}

function decodeStyleTableFromBytes(data: Uint8Array): StyleTable {
  const styles = new Map<number, Style>();

  if (data.length < 2) return styles;

  const count = (data[0] ?? 0) | ((data[1] ?? 0) << 8);
  let offset = 2;

  for (let i = 0; i < count && offset + 16 <= data.length; i++) {
    const styleId = (data[offset] ?? 0) | ((data[offset + 1] ?? 0) << 8);
    offset += 2;

    const fgColor = decodeColor(data, offset);
    const bgColor = decodeColor(data, offset + 4);
    const underlineColor = decodeColor(data, offset + 8);

    const flagsWord = (data[offset + 12] ?? 0) | ((data[offset + 13] ?? 0) << 8);
    const underlineRaw = (flagsWord >> 8) & 0x07;
    const underline: UnderlineValue = (underlineRaw <= 5 ? underlineRaw : Underline.NONE) as UnderlineValue;

    const flags = {
      bold: (flagsWord & 0x01) !== 0,
      italic: (flagsWord & 0x02) !== 0,
      faint: (flagsWord & 0x04) !== 0,
      blink: (flagsWord & 0x08) !== 0,
      inverse: (flagsWord & 0x10) !== 0,
      invisible: (flagsWord & 0x20) !== 0,
      strikethrough: (flagsWord & 0x40) !== 0,
      overline: (flagsWord & 0x80) !== 0,
      underline,
    };

    offset += 14;

    styles.set(styleId, { fgColor, bgColor, underlineColor, flags });
  }

  return styles;
}

function decodeRowIdsFromBytes(data: Uint8Array): bigint[] {
  if (!data || data.length === 0) {
    return [];
  }

  const bytes = data instanceof Uint8Array ? data : new Uint8Array(data);
  const rowIds: bigint[] = [];
  const view = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);

  for (let i = 0; i < bytes.length; i += 8) {
    const lo = view.getUint32(i, true);
    const hi = view.getUint32(i + 4, true);
    const rowId = BigInt(lo) | (BigInt(hi) << 32n);
    rowIds.push(rowId);
  }

  return rowIds;
}

function decodeSnapshot(raw: Uint8Array): DecodedSnapshot {
  const msg = decompressMessage(raw) as BinarySnapshot;

  if (msg.type !== "snapshot") {
    throw new Error(`Expected snapshot, got ${msg.type}`);
  }

  return {
    gen: msg.gen,
    cols: msg.cols,
    rows: msg.rows,
    cursor: msg.cursor,
    altScreen: msg.altScreen,
    cells: decodeCellsFromBytes(msg.cells),
    styles: decodeStyleTableFromBytes(msg.styles),
    rowIds: decodeRowIdsFromBytes(msg.rowIds),
  };
}

function decodeDelta(raw: Uint8Array): BinaryDelta {
  const msg = decompressMessage(raw) as BinaryDelta;

  if (msg.type !== "delta") {
    throw new Error(`Expected delta, got ${msg.type}`);
  }

  return msg;
}

// ============================================================================
// Delta application logic (mirrors connection.ts applyDelta)
// ============================================================================

function applyDelta(snapshotA: DecodedSnapshot, delta: BinaryDelta): DecodedSnapshot {
  // Build row cache from snapshot A
  // NOTE: rowId=0 IS valid (page serial 0, row index 0)
  // The server only uses 0 as "invalid" when the row pin is null (row doesn't exist)
  const rowCache = new Map<bigint, Cell[]>();
  for (let y = 0; y < snapshotA.rows; y++) {
    const rowId = snapshotA.rowIds[y];
    if (rowId !== undefined) {
      const rowCells = snapshotA.cells.slice(y * snapshotA.cols, (y + 1) * snapshotA.cols);
      rowCache.set(rowId, rowCells);
    }
  }

  // Apply dirty rows from delta to cache
  for (const row of delta.dirtyRows) {
    const rowId = BigInt(row.id);
    const cells = decodeCellsFromBytes(row.cells);
    rowCache.set(rowId, cells);
  }

  // Decode row IDs from delta (tells us which rows are in new viewport)
  const newRowIds = decodeRowIdsFromBytes(delta.rowIds);

  // Build cells array from cache for new viewport
  // NOTE: rowId=0 IS valid, only undefined means "no row"
  const cells: Cell[] = [];
  for (let y = 0; y < delta.rows; y++) {
    const rowId = newRowIds[y];
    if (rowId !== undefined) {
      const rowCells = rowCache.get(rowId);
      if (rowCells) {
        cells.push(...rowCells);
        continue;
      }
    }
    // Fill with empty cells if row not in cache
    for (let x = 0; x < delta.cols; x++) {
      cells.push({
        content: { tag: ContentTag.CODEPOINT, codepoint: 32 },
        styleId: 0,
        wide: Wide.NARROW,
        protected: false,
        hyperlink: false,
      });
    }
  }

  // Merge styles
  const styles = new Map(snapshotA.styles);
  const deltaStyles = decodeStyleTableFromBytes(delta.styles);
  for (const [id, style] of deltaStyles) {
    styles.set(id, style);
  }

  return {
    gen: delta.gen,
    cols: delta.cols,
    rows: delta.rows,
    cursor: delta.cursor,
    altScreen: delta.altScreen,
    cells,
    styles,
    rowIds: newRowIds,
  };
}

// ============================================================================
// Comparison helpers
// ============================================================================

function compareCells(a: Cell[], b: Cell[], cols: number, rows: number): string[] {
  const errors: string[] = [];

  if (a.length !== b.length) {
    errors.push(`Cell count mismatch: ${a.length} vs ${b.length}`);
    return errors;
  }

  for (let y = 0; y < rows; y++) {
    for (let x = 0; x < cols; x++) {
      const idx = y * cols + x;
      const cellA = a[idx];
      const cellB = b[idx];

      if (!cellA || !cellB) {
        errors.push(`Missing cell at (${x}, ${y})`);
        continue;
      }

      // Compare content
      if (cellA.content.tag !== cellB.content.tag) {
        errors.push(`Cell (${x}, ${y}): content tag mismatch: ${cellA.content.tag} vs ${cellB.content.tag}`);
      } else if (cellA.content.tag === ContentTag.CODEPOINT || cellA.content.tag === ContentTag.CODEPOINT_GRAPHEME) {
        if ((cellA.content as any).codepoint !== (cellB.content as any).codepoint) {
          const cpA = (cellA.content as any).codepoint;
          const cpB = (cellB.content as any).codepoint;
          const charA = cpA >= 32 && cpA < 127 ? String.fromCodePoint(cpA) : `U+${cpA.toString(16)}`;
          const charB = cpB >= 32 && cpB < 127 ? String.fromCodePoint(cpB) : `U+${cpB.toString(16)}`;
          errors.push(`Cell (${x}, ${y}): codepoint mismatch: '${charA}' vs '${charB}'`);
        }
      }

      // Compare style
      if (cellA.styleId !== cellB.styleId) {
        errors.push(`Cell (${x}, ${y}): styleId mismatch: ${cellA.styleId} vs ${cellB.styleId}`);
      }

      // Compare wide flag
      if (cellA.wide !== cellB.wide) {
        errors.push(`Cell (${x}, ${y}): wide mismatch: ${cellA.wide} vs ${cellB.wide}`);
      }
    }
  }

  return errors;
}

function compareSnapshots(applied: DecodedSnapshot, expected: DecodedSnapshot): string[] {
  const errors: string[] = [];

  // Compare dimensions
  if (applied.cols !== expected.cols) {
    errors.push(`cols mismatch: ${applied.cols} vs ${expected.cols}`);
  }
  if (applied.rows !== expected.rows) {
    errors.push(`rows mismatch: ${applied.rows} vs ${expected.rows}`);
  }

  // Compare cursor
  if (applied.cursor.x !== expected.cursor.x || applied.cursor.y !== expected.cursor.y) {
    errors.push(
      `cursor position mismatch: (${applied.cursor.x}, ${applied.cursor.y}) vs (${expected.cursor.x}, ${expected.cursor.y})`
    );
  }
  if (applied.cursor.visible !== expected.cursor.visible) {
    errors.push(`cursor visible mismatch: ${applied.cursor.visible} vs ${expected.cursor.visible}`);
  }

  // Compare altScreen
  if (applied.altScreen !== expected.altScreen) {
    errors.push(`altScreen mismatch: ${applied.altScreen} vs ${expected.altScreen}`);
  }

  // Compare row IDs
  if (applied.rowIds.length !== expected.rowIds.length) {
    errors.push(`rowIds length mismatch: ${applied.rowIds.length} vs ${expected.rowIds.length}`);
  } else {
    for (let i = 0; i < applied.rowIds.length; i++) {
      if (applied.rowIds[i] !== expected.rowIds[i]) {
        errors.push(`rowIds[${i}] mismatch: ${applied.rowIds[i]} vs ${expected.rowIds[i]}`);
      }
    }
  }

  // Compare cells
  const cellErrors = compareCells(applied.cells, expected.cells, expected.cols, expected.rows);
  errors.push(...cellErrors);

  return errors;
}

// ============================================================================
// Test suite
// ============================================================================

const FIXTURES_DIR = join(import.meta.dir, "../../test_fixtures/delta");

interface TestCase {
  name: string;
  meta: TestMeta;
  snapshotA: Uint8Array;
  snapshotB: Uint8Array;
  delta: Uint8Array;
}

async function loadTestCases(): Promise<TestCase[]> {
  const files = await readdir(FIXTURES_DIR);
  const metaFiles = files.filter((f) => f.endsWith("_meta.json"));

  const cases: TestCase[] = [];

  for (const metaFile of metaFiles) {
    const name = metaFile.replace("_meta.json", "");
    const meta: TestMeta = JSON.parse(await readFile(join(FIXTURES_DIR, metaFile), "utf-8"));

    const snapshotA = new Uint8Array(await readFile(join(FIXTURES_DIR, `${name}_snapshot_a.bin`)));
    const snapshotB = new Uint8Array(await readFile(join(FIXTURES_DIR, `${name}_snapshot_b.bin`)));
    const delta = new Uint8Array(await readFile(join(FIXTURES_DIR, `${name}_delta.bin`)));

    cases.push({ name, meta, snapshotA, snapshotB, delta });
  }

  return cases;
}

describe("Delta sync", () => {
  let testCases: TestCase[] = [];

  beforeAll(async () => {
    try {
      testCases = await loadTestCases();
    } catch (e) {
      console.error("Failed to load test fixtures. Run: cd server && zig build gen-delta-test");
      throw e;
    }
  });

  test("fixtures exist", () => {
    expect(testCases.length).toBeGreaterThan(0);
    console.log(`Loaded ${testCases.length} test cases`);
  });

  test("snapshot A decodes correctly", () => {
    for (const tc of testCases) {
      const snapshot = decodeSnapshot(tc.snapshotA);
      expect(snapshot.cols).toBe(tc.meta.cols);
      expect(snapshot.rows).toBe(tc.meta.rows);
      expect(snapshot.cells.length).toBe(tc.meta.cols * tc.meta.rows);
    }
  });

  test("snapshot B decodes correctly", () => {
    for (const tc of testCases) {
      const snapshot = decodeSnapshot(tc.snapshotB);
      expect(snapshot.cols).toBe(tc.meta.cols);
      expect(snapshot.rows).toBe(tc.meta.rows);
      expect(snapshot.cells.length).toBe(tc.meta.cols * tc.meta.rows);
    }
  });

  test("delta decodes correctly", () => {
    for (const tc of testCases) {
      const delta = decodeDelta(tc.delta);
      expect(delta.cols).toBe(tc.meta.cols);
      expect(delta.rows).toBe(tc.meta.rows);
      expect(delta.gen).toBe(tc.meta.gen_b);
    }
  });

  test("applying delta to A produces B", () => {
    for (const tc of testCases) {
      console.log(`\n=== Test case: ${tc.name} ===`);

      const snapshotA = decodeSnapshot(tc.snapshotA);
      const snapshotB = decodeSnapshot(tc.snapshotB);
      const delta = decodeDelta(tc.delta);

      console.log(`Snapshot A: gen=${snapshotA.gen}, ${snapshotA.cols}x${snapshotA.rows}`);
      console.log(`Snapshot B: gen=${snapshotB.gen}, ${snapshotB.cols}x${snapshotB.rows}`);
      console.log(`Delta: gen=${delta.gen}, ${delta.dirtyRows.length} dirty rows`);
      console.log(`Delta rowIds:`, delta.rowIds ? decodeRowIdsFromBytes(delta.rowIds).map(String) : "missing");
      console.log(`Snapshot A rowIds:`, snapshotA.rowIds.map(String));
      console.log(`Snapshot B rowIds:`, snapshotB.rowIds.map(String));

      const applied = applyDelta(snapshotA, delta);
      const errors = compareSnapshots(applied, snapshotB);

      if (errors.length > 0) {
        console.log(`\nErrors for ${tc.name}:`);
        for (const err of errors.slice(0, 20)) {
          console.log(`  - ${err}`);
        }
        if (errors.length > 20) {
          console.log(`  ... and ${errors.length - 20} more errors`);
        }
      }

      expect(errors).toEqual([]);
    }
  });
});

// ============================================================================
// Debug helpers
// ============================================================================

function cellsToText(cells: Cell[], cols: number, rows: number): string {
  const lines: string[] = [];
  for (let y = 0; y < rows; y++) {
    let line = "";
    for (let x = 0; x < cols; x++) {
      const cell = cells[y * cols + x];
      if (cell?.content.tag === ContentTag.CODEPOINT || cell?.content.tag === ContentTag.CODEPOINT_GRAPHEME) {
        const cp = (cell.content as any).codepoint;
        line += cp >= 32 && cp < 127 ? String.fromCodePoint(cp) : " ";
      } else {
        line += " ";
      }
    }
    lines.push(line.trimEnd());
  }
  return lines.join("\n");
}

// Additional debug test
describe("Debug visualization", () => {
  test("show snapshot content", async () => {
    const testCases = await loadTestCases();

    for (const tc of testCases) {
      console.log(`\n=== ${tc.name} ===`);

      const snapshotA = decodeSnapshot(tc.snapshotA);
      const snapshotB = decodeSnapshot(tc.snapshotB);
      const delta = decodeDelta(tc.delta);
      const applied = applyDelta(snapshotA, delta);

      console.log("\nSnapshot A content:");
      console.log(cellsToText(snapshotA.cells, snapshotA.cols, snapshotA.rows));

      console.log("\nSnapshot B content (expected):");
      console.log(cellsToText(snapshotB.cells, snapshotB.cols, snapshotB.rows));

      console.log("\nApplied (A + delta):");
      console.log(cellsToText(applied.cells, applied.cols, applied.rows));
    }
  });
});
